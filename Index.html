<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Index</title>
<link rel="stylesheet" href="css/layout.css" />
<script type="text/javascript" src="js/three.js"></script>
<script type="text/javascript" src="js/label.js"></script>
<script type="text/javascript" src="js/CameraPlayer.js"></script>
<script type="text/javascript" src="js/MeshMove.js"></script>
<script type="text/javascript" src="js/planePos.js"></script>
<!-- some tutorial https://stemkoski.github.io/Three.js/#mesh-movement-->
</head>
<body>
<script>

//--> base variables start 
var clock = new THREE.Clock();
var scene = new THREE.Scene();
var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 700 );
//<-- base variables end			
//--> renderer definition start
var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );
//<-- renderer definition end
/******************** OBJECT DEFINITIONS START  *********************/ 
//--> create cube start
var textureCube = THREE.ImageUtils.loadTexture( "img/textures/BoxTextures/crate_1.jpg" );
var geometry = new THREE.BoxGeometry( 20, 20, 20 );
var material = new THREE.MeshLambertMaterial( { map : textureCube }  );
var cube = new THREE.Mesh( geometry, material );
cube.position.z=10;
scene.add( cube );
//<-- create cube end
//--> create light start
var lightPoint = new THREE.PointLight( 0xFFFFFF, 2, 1000 );
lightPoint.position.set( 50, 50, 50 );
scene.add( lightPoint );
lightPoint.position.z = 100;

var lightAmbient = new THREE.AmbientLight( 0x404040 ); // soft white light
scene.add( lightAmbient );
//<-- create light end
scene.fog = new THREE.FogExp2( 0xFFFFFF, 0.0019 );
//-->create plane start
var texture = THREE.ImageUtils.loadTexture( "img/textures/Grass/Grass1.png" );
texture.wrapS = THREE.RepeatWrapping; 
texture.wrapT = THREE.RepeatWrapping;
texture.repeat.set( 10, 10 ); 
var planeW=1000;
var planeH=1000; 
var planeWs=100;
var planeHs=100;
var planeGeo =  new THREE.PlaneGeometry(planeW,planeH,planeWs,planeHs);
var planeMat = new THREE.MeshLambertMaterial( { map : texture } );
var plane = new THREE.Mesh(planeGeo, planeMat);
scene.add( plane );

//<--create plane end
//--> camera settings start
camera.position.z = 1000;
camera.rotation.x = 45 * Math.PI / 180;
//<-- camera settings end
/******************** OBJECT DEFINITIONS END ********************/

/******************** PLAYER FUNCTIONS START ********************/
document.addEventListener( 'keydown', keyDown, false );
document.addEventListener( 'keyup', keyUp, false );
var camPlayer= new CameraPlayer(cube,camera);
var delta;
var meshMove = new  MeshMove(cube);
meshMove.setSpeed(100);
var planePos = new PlanePos();//<-- for nearest vertice and segment calculation
var temp=planePos.getSegment(planeW, planeH, planeWs, planeHs,cube.position.x,cube.position.y);
//window.alert("temp"+temp);
//document.getElementById("CurentSegment").innerHTML=temp;

function keyDown(event){
	switch(event.keyCode){
     case 37 : //left arrow 
	 meshMove.setLeft(1);
    break;
    case 38 : // up arrow  
	 meshMove.setForward(1);
    break;
    case 39 : // right arrow 
     meshMove.setRight(1);
    break;
    case 40 : //down arrow
     meshMove.setBack(1);
    break;
	case 107 : //inrease terrain
     editPlane(planePos.getVertices(planeW, planeH, planeWs, planeHs,cube.position.x,cube.position.y),10,plane);
    break;
	case 109 : //lower terrain
     editPlane(planePos.getVertices(planeW, planeH, planeWs, planeHs,cube.position.x,cube.position.y), -10,plane);
    break;
	}
	
	
}//<-- keyDown end
function keyUp(event){
	switch(event.keyCode){
     case 37 : //left arrow 
	 meshMove.setLeft(0);
    break;
    case 38 : // up arrow  
	 meshMove.setForward(0);
    break;
    case 39 : // right arrow 
     meshMove.setRight(0);
    break;
    case 40 : //down arrow
     meshMove.setBack(0);
    break;
	}
}//<-- key up end

function editPlane(verticeId, height,plane){
  for(i=0;i<4;i++){
  if(i==1)verticeId+=1;
  if(i==2)verticeId+=planeWs;
  if(i==3)verticeId+=1;	
  plane.geometry.vertices[verticeId].z += height;
  }
  planeGeo.verticesNeedUpdate = true;
}//<-- palne edit end

/*
for ( var i = 0; i<plane.geometry.vertices.length; i++ ) {
         plane.geometry.vertices[i].z = Math.floor((Math.random() * 100) + 1);;
    }
	*/
function update(delta){
updateLabel(delta);
camera=camPlayer.setPos(cube.position.x,cube.position.y-100,cube.position.z+150);
meshMove.update(delta);

}//<--

/******************** PLAYER FUNCTIONS END ********************/
//--> renderer function start
var render = function () {
requestAnimationFrame( render );
renderer.render(scene, camera);
//update label
delta = clock.getDelta();
update(delta);
//cameraFollow


};
//<-- renderer function end
//--> function init start
render();
//<-- function init end
</script>
<div id="label">
Camera position: <span class="labelValues">
<span id="CamX">0</span>
<span id="CamY">0</span>
<span id="CamZ">0</span>
</span><br />
Plane vertice count: <span class="labelValues">
<span id="PlaneVertices">0</span>
</span><br />
Curent segment: <span class="labelValues">
<span id="CurentSegment">0</span>
</span><br />
Left Top verticet: <span class="labelValues">
<span id="LeftVertice">0</span>
</span><br />
</div>
<div id="console">
<textarea name="message"  readonly="readonly">
command: spawn cube
command: spawn undo
command: spawn redo
command: help
</textarea><br>
<input type="text" name="command">

</div>



</body>
</html>
